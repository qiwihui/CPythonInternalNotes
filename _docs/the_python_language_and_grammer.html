

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Python 语言和语法 &mdash; CPython Internal 笔记 0.0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="标准库" href="the_standard_library.html" />
    <link rel="prev" title="编译 CPython" href="compiling_cpython.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> CPython Internal 笔记
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          

            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="setting_up_your_development_environment.html">设置开发环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_cpython.html">编译 CPython</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python 语言和语法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cpython-c-python">为什么 CPython 是用 C 而不是用 Python 编写</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Python 语言规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">语言文档</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">一个例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">语法文件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-parser-generator">使用解析器生成器（The Parser Generator）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">解析器生成器</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">重新生成语法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tokens">标记（Tokens）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">一个更复杂的例子</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="the_standard_library.html">标准库</a></li>
</ul>

            
          
<style>
.adsbygoogle-style {
  background-color: rgb(52, 49, 49);
  margin-top: 20px;
}
</style>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- square-ad -->
<ins class="adsbygoogle adsbygoogle-style"
     style="display:block"
     data-ad-client="ca-pub-8935595858652656"
     data-ad-slot="2636787302"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CPython Internal 笔记</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Python 语言和语法</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/_docs/the_python_language_and_grammer.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="python">
<h1>Python 语言和语法<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h1>
<p>编译器的目的是将一种语言转换成另一种语言。把编译器想象成一个翻译器。
比如你会雇一个翻译来听你说英语，然后翻译成日语。</p>
<p>为此，翻译人员必须了解源语言和目标语言的语法结构。</p>
<p>有些编译器会编译成低级机器码，可以直接在系统上执行。其他编译器会编译成一种中间语言，由虚拟机执行。</p>
<p>选择编译器时的一个考虑因素是系统可移植性要求。
<a class="reference external" href="https://en.wikipedia.org/wiki/Java_bytecode">Java</a>
和 <a class="reference external" href="https://en.wikipedia.org/wiki/Common_Language_Runtime">.NET CLR</a>
将编译成一种中间语言，以便编译后的代码可以跨多个系统架构移植。
C、Go、C++ 和 Pascal 将编译成可执行的二进制文件。此二进制文件是为编译它的平台构建的。</p>
<p>Python 应用程序通常作为源代码分发。Python 解释器的作用是将Python源代码进行转换并一步执行。
CPython 运行时在第一次运行时会编译你的代码。这一步对普通用户是不可见的。</p>
<p>Python 代码不会被编译成机器码；它被编译成一种称为 <strong>字节码</strong> 的低级中间语言。
此字节码存储在 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件中并缓存以供执行。
如果在不更改源代码的情况下两次运行同一个 Python 应用程序，则第二次执行速度会更快。
这是因为它加载编译后的字节码而不是每次都重新编译。</p>
<div class="section" id="cpython-c-python">
<h2>为什么 CPython 是用 C 而不是用 Python 编写<a class="headerlink" href="#cpython-c-python" title="永久链接至标题">¶</a></h2>
<p>CPython 中的 <strong>C</strong> 是对 C 编程语言的引用，这意味着这个 Python 发行版是用 C 语言编写的。</p>
<p>这种说法大多是正确的：CPython 中的编译器是用纯 C 编写的。
但是，许多标准库模块是用纯 Python 或 C 和 Python 组合编写的。</p>
<p><strong>那么为什么 CPython 编译器是用 C 而不是 Python 编写的呢？</strong></p>
<p>答案在于编译器的工作方式。 有两种类型的编译器：</p>
<ol class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Self-hosting_(compilers)">自举编译器</a>
是用它们编译的语言编写的编译器，例如 Go 编译器。这是通过称为引导的过程完成的。</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Source-to-source_compiler">源到源编译器</a>
是用另一种已经有编译器的语言编写的编译器。</p></li>
</ol>
<p>如果你要从头开始编写新的编程语言，则需要一个可执行应用程序来编译你的编译器！
你需要一个编译器来执行任何事情，所以当开发新语言时，它们通常首先用更老的、更成熟的语言编写。</p>
<p>还有一些可用的工具可以读取语言规范并创建解析器。
流行的编译器-编译器（compiler-compilers）包括 GNU Bison、Yacc 和 ANTLR。</p>
<blockquote>
<div><p>如果你想了解有关解析器的更多信息，请查看 <a class="reference external" href="https://github.com/lark-parser/lark">lark</a> 项目。
Lark 是一个用 Python 编写的上下文无关语法解析器。</p>
</div></blockquote>
<p>编译器引导的一个很好的例子是 Go 编程语言。
第一个 Go 编译器是用 C 编写的，然后一旦 Go 可以编译了，就用 Go 重写编译器。</p>
<p>CPython 保留了 C 语言的传统；许多标准库模块，如 ssl 模块或套接字模块，都是用 C 编写的，用于访问低级操作系统 API。
Windows 和 Linux 内核中用于<a class="reference external" href="https://realpython.com/python-sockets/">创建网络套接字</a>、
<a class="reference external" href="https://realpython.com/working-with-files-in-python/">使用文件系统</a>或
<a class="reference external" href="https://realpython.com/python-gui-with-wxpython/">与显示器交互</a>的 API 都是用 C 编写的。
Python 的可扩展性层专注于 C 语言是有意义的。</p>
<p>有一个用 Python 编写的 Python 编译器，称为 PyPy。
PyPy 的标志是一个 <a class="reference external" href="https://en.wikipedia.org/wiki/Ouroboros">衔尾蛇</a>，代表编译器的自举性质。</p>
<p>Python 交叉编译器的另一个示例是 Jython。Jython 是用 Java 编写的，从 Python 源代码编译成 Java 字节码。
与 CPython 可以轻松导入 C 库并从 Python 中使用它们一样，Jython 可以轻松导入和引用 Java 模块和类。</p>
<p>创建编译器的第一步是定义语言。 例如，一下不是有效的 Python：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_example</span><span class="p">()</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">:</span>
<span class="p">{</span>
    <span class="n">void</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>编译器在尝试执行之前需要严格的语言语法结构规则。</p>
<blockquote>
<div><p>对于本书的其余部分，<code class="docutils literal notranslate"><span class="pre">./python</span></code> 将指代 CPython 的编译版本。 但是，实际命令将取决于你的操作系统。</p>
<p>对于 Windows：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">python</span><span class="o">.</span><span class="n">exe</span>
</pre></div>
</div>
<p>对于 Linux：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>$ ./python
</pre></div>
</div>
<p>对于 macOS：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>$ ./python.exe
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id1">
<h2>Python 语言规范<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>CPython 源代码中包含 Python 语言的定义。这个文档是所有 Python 解释器使用的参考规范。</p>
<p>该规范采用人类可读和机器可读的格式。文档里面是对 Python 语言的详细解释。包含允许的内容以及每个语句的行为方式。</p>
<div class="section" id="id2">
<h3>语言文档<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>位于 <code class="docutils literal notranslate"><span class="pre">Doc/reference</span></code> 目录中的是 Python 语言中每个功能的 <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructured-Text</a> 解释。
这些文件构成了 <a class="reference external" href="https://docs.python.org/3/reference/">docs.python.org/3/reference</a> 上的官方 Python 参考指南。</p>
<p>目录里面是你需要了解整个语言、结构和关键字的文件：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cpython/Doc/reference/
├── compound_stmts.rst          复合语句，如 if、while、for 和函数定义
├── datamodel.rst               对象、值和类型
├── executionmodel.rst          Python程序的结构
├── expressions.rst             Python 表达式的元素
├── grammar.rst                 Python 的核心语法（参考 Grammar/Grammar）
├── import.rst                  导入系统
├── index.rst                   语言参考索引
├── introduction.rst            参考文档介绍
├── lexical_analysis.rst        词法结构，如行、缩进、标记和关键字
├── simple_stmts.rst            简单的语句，如 assert、import、return 和 yield
└── toplevel_components.rst     执行 Python 的方式的描述，如脚本和模块
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>一个例子<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Doc/reference/compound_stmts.rst</span></code>，你可以看到一个定义 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句的简单示例。</p>
<p><code class="docutils literal notranslate"><span class="pre">with</span></code> 语句有多种形式，最简单的是上下文管理器的实例化和嵌套的代码块：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">x</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>你可以使用 <code class="docutils literal notranslate"><span class="pre">as</span></code> 关键字将结果分配给变量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">x</span><span class="p">()</span> <span class="k">as</span> <span class="n">y</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>你还可以使用逗号将上下文管理器链接在一起：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">x</span><span class="p">()</span> <span class="k">as</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">()</span> <span class="k">as</span> <span class="n">jk</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>文档包含语言的人类可读规范，机器可读规范包含在单个文件 <code class="docutils literal notranslate"><span class="pre">Grammar</span> <span class="pre">Grammar</span></code> 中。</p>
</div>
<div class="section" id="id4">
<h3>语法文件<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>本节指的是“旧解析器”使用的语法文件。 在发布时，“新解析器”（PEG 解析器）是实验性的，尚未完成。</p>
<p>对于 3.8 及以下版本的 CPython，默认使用 pgen 解析器。
对于 CPython 3.9 及更高版本，PEG 解析器是默认的。可以在命令行上使用 <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">oldparser</span></code> 启用旧解析器。</p>
<p>两个解析器都使用 <code class="docutils literal notranslate"><span class="pre">Tokens</span></code> 文件。</p>
</div></blockquote>
<p>语法文件以一种称为<a class="reference external" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">巴科斯范式</a> (BNF) 的上下文符号编写。
巴科斯范式不是 Python 特有的，通常用作许多其他语言中的语法符号。</p>
<p>编程语言中语法结构的概念受到 <a class="reference external" href="https://en.wikipedia.org/wiki/Syntactic_Structures">Noam Chomsky 在 1950 年代关于句法结构的工作</a>的启发！</p>
<p>Python 的语法文件使用扩展巴科斯范式（EBNF）规范和正则表达式语法。因此，在语法文件中，你可以使用：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">*</span></code> 用于重复</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code> 至少重复一次</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[]</span></code> 用于可选部分</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">|</span></code> 对于替代品</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">()</span></code> 用于分组</p></li>
</ul>
<p>例如，考虑如何定义一杯咖啡：</p>
<ul class="simple">
<li><p>它必须有一个杯子</p></li>
<li><p>它必须包括至少一瓶浓缩咖啡（espresso），并且可以包含多个</p></li>
<li><p>它可以有牛奶，但可选</p></li>
<li><p>你可以在咖啡中加入多种牛奶，如全脂、脱脂和豆奶（soy）</p></li>
</ul>
<p>在 EBNF 中定义的咖啡订单可能如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>coffee: &#39;cup&#39; (&#39;espresso&#39;)+ [&#39;water&#39;] [milk]
milk: &#39;full-fat&#39; | &#39;skimmed&#39; | &#39;soy&#39;
</pre></div>
</div>
<p>在本章中，语法是用铁路图形象化的。 这张图是咖啡语句的铁路图：</p>
<p><img alt="coffee_statement" src="../_images/coffee_statement.png" /></p>
<p>在铁路图中，每个可能的组合必须从左到右排成一条线。 可选语句可以被绕过，有些语句可以形成循环。</p>
<p>如果在语法文件中搜索 <code class="docutils literal notranslate"><span class="pre">with_stmt</span></code>，可以看到定义：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>with_stmt: &#39;with&#39; with_item (&#39;,&#39; with_item)*  &#39;:&#39; suite
with_item: test [&#39;as&#39; expr]
</pre></div>
</div>
<p>引号中的任何内容都是字符串文字，称为终端（terminal）。终端是识别关键字的方式。<code class="docutils literal notranslate"><span class="pre">with_stmt</span></code> 指定为：</p>
<ol class="simple">
<li><p>从 <code class="docutils literal notranslate"><span class="pre">with</span></code> 开始</p></li>
<li><p>后面跟一个 <code class="docutils literal notranslate"><span class="pre">with_item</span></code>，它可以是 <code class="docutils literal notranslate"><span class="pre">test</span></code>，和（可选的） <code class="docutils literal notranslate"><span class="pre">as</span></code> 以及一个表达式 <code class="docutils literal notranslate"><span class="pre">expr</span></code></p></li>
<li><p>接着是一个或多个 <code class="docutils literal notranslate"><span class="pre">with_item</span></code>，每个都用逗号隔开</p></li>
<li><p>以 <code class="docutils literal notranslate"><span class="pre">:</span></code> 结尾</p></li>
<li><p>跟一个 <code class="docutils literal notranslate"><span class="pre">suite</span></code></p></li>
</ol>
<p>在这两行中引用了其他三个定义：</p>
<p>• <code class="docutils literal notranslate"><span class="pre">suite</span></code> 是指包含一个或多个语句的代码块
• <code class="docutils literal notranslate"><span class="pre">test</span></code> 指的是一个被评估的简单的语句
• <code class="docutils literal notranslate"><span class="pre">expr</span></code> 指的是一个简单的表达式</p>
<p>在铁路图中可视化，<code class="docutils literal notranslate"><span class="pre">with</span></code> 语句如下所示：</p>
<p><img alt="with_stmt" src="../_images/with_stmt.png" /></p>
<p>作为一个更复杂的例子，<code class="docutils literal notranslate"><span class="pre">try</span></code> 语句定义为：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>try_stmt: (&#39;try&#39; &#39;:&#39; suite
           ((except_clause &#39;:&#39; suite)+
            [&#39;else&#39; &#39;:&#39; suite]
            [&#39;finally&#39; &#39;:&#39; suite] |
           &#39;finally&#39; &#39;:&#39; suite))
except_clause: &#39;except&#39; [test [&#39;as&#39; NAME]]
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">try</span></code> 语句有两种用途：</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">try</span></code> 和一个或多个 <code class="docutils literal notranslate"><span class="pre">except</span></code> 子句，然后是一个可选的 <code class="docutils literal notranslate"><span class="pre">else</span></code>，然后是一个可选的 <code class="docutils literal notranslate"><span class="pre">finally</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">try</span></code> 和只有一个 <code class="docutils literal notranslate"><span class="pre">finally</span></code> 语句</p></li>
</ol>
<p>或者，在铁路图中可视化：</p>
<p><img alt="try_stmt" src="../_images/try_stmt.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">try</span></code> 语句是更复杂结构的一个很好的例子。</p>
<p>如果你想详细了解 Python 语言，语法在 <code class="docutils literal notranslate"><span class="pre">Grammar/Grammar</span></code> 中定义。</p>
</div>
</div>
<div class="section" id="the-parser-generator">
<h2>使用解析器生成器（The Parser Generator）<a class="headerlink" href="#the-parser-generator" title="永久链接至标题">¶</a></h2>
<p>Python 编译器从不使用语法文件本身。相反，解析器表由解析器生成器创建。
如果对语法文件进行更改，则必须重新生成解析器表并重新编译 CPython。</p>
<p>解析器表是潜在解析器状态的列表。当解析树变得复杂时，它们确保语法不会有歧义。</p>
</div>
<div class="section" id="id5">
<h2>解析器生成器<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>解析器生成器的工作原理是将 EBNF 语句转换为非确定性有限自动机 (Non-deterministic Finite Automaton，NFA)。
NFA 状态和转换被解析并合并为一个确定性有限自动机 (Deterministic Finite Automaton，DFA)。</p>
<p>DFA 被解析器用作解析表。这种技术是<a class="reference external" href="http://infolab.stanford.edu/~ullman/dragon/slides1.pdf">在斯坦福大学形成的</a>，并在 1980 年代开发，就在 Python 出现之前。
CPython 的解析器生成器 <code class="docutils literal notranslate"><span class="pre">pgen</span></code> 是 CPython 项目独有的。</p>
<p><code class="docutils literal notranslate"><span class="pre">pgen</span></code> 应用程序在 Python 3.8 中从 C 重写为 Python，在文件 <code class="docutils literal notranslate"><span class="pre">Parser/pgen/pgen.py</span></code> 中。</p>
<p>它可通过以下执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ./python -m Parser.pgen <span class="o">[</span>grammar<span class="o">]</span> <span class="o">[</span>tokens<span class="o">]</span> <span class="o">[</span>graminit.h<span class="o">]</span> <span class="o">[</span>graminit.c<span class="o">]</span>
</pre></div>
</div>
<p>它通常从构建脚本执行，而不是直接执行。</p>
<p>DFA 和 NFA 没有视觉输出，但有一个带有有向图输出的 <a class="reference external" href="https://github.com/tonybaloney/cpython/tree/dot_pgen">CPython 分支</a>。
<code class="docutils literal notranslate"><span class="pre">decorator</span></code> 语法在 <code class="docutils literal notranslate"><span class="pre">Grammar/Grammar</span></code> 中定义为：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>decorator: &#39;@&#39; dotted_name [ &#39;(&#39; [arglist] &#39;)&#39; ] NEWLINE
</pre></div>
</div>
<p>解析器生成器创建了一个包含 11 个状态的复杂 NFA 图。每个状态都用数字表示（在语法中提示它们的名称）。
状态转移被称为“弧”。</p>
<p>DFA 比 NFA 更简单，路径减少了：</p>
<p><img alt="decorator_DFA" src="../_images/decorator_DFA.png" /></p>
<p>NFA 和 DFA 图仅用于调试复杂语法的设计。</p>
<p>我们将使用铁路图代替 DFA 或 NFA 图来表示语法。例如，此图表示 <code class="docutils literal notranslate"><span class="pre">decorator</span></code> 语句可以采用的路径：</p>
<p><img alt="decorator_stmt" src="../_images/decorator_stmt.png" /></p>
</div>
<div class="section" id="id6">
<h2>重新生成语法<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>要查看 <code class="docutils literal notranslate"><span class="pre">pgen</span></code> 的运行情况，让我们更改部分 Python 语法。
在 <code class="docutils literal notranslate"><span class="pre">Grammar/Grammar</span></code> 中搜索 <code class="docutils literal notranslate"><span class="pre">pass_stmt</span></code> 以查看 <code class="docutils literal notranslate"><span class="pre">pass</span></code> 语句的定义：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>pass_stmt: &#39;pass&#39;
</pre></div>
</div>
<p><img alt="pass_stmt" src="../_images/pass_stmt.png" /></p>
<p>通过添加选择 <code class="docutils literal notranslate"><span class="pre">|</span></code> 和 <code class="docutils literal notranslate"><span class="pre">proceed</span></code> 字面量，更改该行以接受终端（关键字）<code class="docutils literal notranslate"><span class="pre">'pass'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'proceed'</span></code> 作为关键字：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>pass_stmt: &#39;pass&#39; | &#39;proceed&#39;
</pre></div>
</div>
<p><img alt="pass_stmt_modified" src="../_images/pass_stmt_modified.png" /></p>
<p>接下来，通过运行 <code class="docutils literal notranslate"><span class="pre">pgen</span></code> 重建语法文件。CPython 带有脚本来自动化 <code class="docutils literal notranslate"><span class="pre">pgen</span></code>。</p>
<p>在 macOS 和 Linux 上，运行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-grammar</span></code>：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ make regen-grammar
</pre></div>
</div>
<p>对于 Windows，从 PCBuild 目录调出命令行并使用 <code class="docutils literal notranslate"><span class="pre">--regen</span></code> 标志运行 <code class="docutils literal notranslate"><span class="pre">build.bat</span></code>：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt; build.bat --regen
</pre></div>
</div>
<p>你应该会看到一个输出，显示新的 <code class="docutils literal notranslate"><span class="pre">Include/graminit.h</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Python/graminit.c</span></code> 文件已重新生成。</p>
<p>使用重新生成的解析器表，当你重新编译 CPython 时，它将使用新语法。</p>
<p>如果代码编译成功，你可以执行新的 CPython 二进制文件并启动 REPL。</p>
<p>在 REPL 中，你现在可以尝试定义一个函数。不要使用 pass 语句，
而是使用你编译到 Python 语法中的 <code class="docutils literal notranslate"><span class="pre">proceed</span></code> 关键字替代 <code class="docutils literal notranslate"><span class="pre">pass</span></code>：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ./python -X oldparser
Python <span class="m">3</span>.9.0b1 <span class="o">(</span>tags/v3.9.0b1:97fe9cf, May <span class="m">19</span> <span class="m">2020</span>, <span class="m">10</span>:00:00<span class="o">)</span>
<span class="o">[</span>Clang <span class="m">10</span>.0.1 <span class="o">(</span>clang-1001.0.46.4<span class="o">)]</span> on darwin
Type <span class="s2">&quot;help&quot;</span>, <span class="s2">&quot;copyright&quot;</span>, <span class="s2">&quot;credits&quot;</span> or <span class="s2">&quot;license&quot;</span> <span class="k">for</span> more information.
&gt;&gt;&gt; def example<span class="o">()</span>:
...    proceed
...
&gt;&gt;&gt; example<span class="o">()</span>
</pre></div>
</div>
<p>恭喜，你已经更改了 CPython 语法并编译了你自己的 CPython 版本。</p>
<p>接下来，我们将探索标记（tokens）及其与语法的关系。</p>
<div class="section" id="tokens">
<h3>标记（Tokens）<a class="headerlink" href="#tokens" title="永久链接至标题">¶</a></h3>
<p>除了 <code class="docutils literal notranslate"><span class="pre">Grammar</span></code> 文件夹中的语法文件之外，还有 <code class="docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code> 文件，
其中包含在分析树中作为叶节点找到的每个唯一类型。每个标记还有一个名称和一个生成的唯一 ID。
名称用于使在分词器（tokenizer）中更容易引用。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code> 文件是 Python 3.8 中的一项新功能。</p>
</div></blockquote>
<p>例如，左括号称为 <code class="docutils literal notranslate"><span class="pre">LPAR</span></code>，分号称为称为 <code class="docutils literal notranslate"><span class="pre">SEMI</span></code>。 你将在本书后面看到这些标记：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LPAR                    &#39;(&#39;
RPAR                    &#39;)&#39;
LSQB                    &#39;[&#39;
RSQB                    &#39;]&#39;
COLON                   &#39;:&#39;
COMMA                   &#39;,&#39;
SEMI                    &#39;;&#39;
</pre></div>
</div>
<p>和 <code class="docutils literal notranslate"><span class="pre">Grammar</span></code> 文件一样，如果你修改了 <code class="docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code> 文件，你需要重新运行 <code class="docutils literal notranslate"><span class="pre">pgen</span></code>。</p>
<p>要查看操作中的标记，你可以使用 CPython 中的 <code class="docutils literal notranslate"><span class="pre">tokenize</span></code> 模块。</p>
<blockquote>
<div><p>CPython 源代码中有两个标记器。这里演示了一个用 Python 编写的分词器，另一个用 C 编写。
用 Python 编写的分词器是一个实用程序，Python 解释器使用用 C 编写的那个。
它们具有相同的输出和行为。用 C 编写的版本是为性能而设计的，而 Python 中的模块是为调试而设计的。</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">cpython-book-samples/13/test_tokens.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Demo application</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span> <span class="n">proceed</span>
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">test_tokens.py</span></code> 文件输入到标准库中内置的名为 <code class="docutils literal notranslate"><span class="pre">tokenize</span></code> 的模块中。你将按行和字符看到标记列表。
使用 <code class="docutils literal notranslate"><span class="pre">-e</span></code> 标志输出确切的标记名称：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ./python -m tokenize -e test_tokens.py

<span class="m">0</span>,0-0,0:            ENCODING       <span class="s1">&#39;utf-8&#39;</span>        
<span class="m">1</span>,0-1,18:           COMMENT        <span class="s1">&#39;# Demo application&#39;</span>
<span class="m">1</span>,18-1,19:          NL             <span class="s1">&#39;\n&#39;</span>           
<span class="m">2</span>,0-2,3:            NAME           <span class="s1">&#39;def&#39;</span>          
<span class="m">2</span>,4-2,15:           NAME           <span class="s1">&#39;my_function&#39;</span>  
<span class="m">2</span>,15-2,16:          LPAR           <span class="s1">&#39;(&#39;</span>            
<span class="m">2</span>,16-2,17:          RPAR           <span class="s1">&#39;)&#39;</span>            
<span class="m">2</span>,17-2,18:          COLON          <span class="s1">&#39;:&#39;</span>            
<span class="m">2</span>,18-2,19:          NEWLINE        <span class="s1">&#39;\n&#39;</span>           
<span class="m">3</span>,0-3,4:            INDENT         <span class="s1">&#39;    &#39;</span>         
<span class="m">3</span>,4-3,11:           NAME           <span class="s1">&#39;proceed&#39;</span>      
<span class="m">3</span>,11-3,12:          NEWLINE        <span class="s1">&#39;\n&#39;</span>           
<span class="m">4</span>,0-4,0:            DEDENT         <span class="s1">&#39;&#39;</span>             
<span class="m">4</span>,0-4,0:            ENDMARKER      <span class="s1">&#39;&#39;</span> 
</pre></div>
</div>
<p>在输出中，第一列是行/列坐标的范围，第二列是标记的名称，最后一列是标记的值。</p>
<p>在输出中， <code class="docutils literal notranslate"><span class="pre">tokenize</span></code> 模块隐含了一些标记：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 的 <code class="docutils literal notranslate"><span class="pre">ENCODING</span></code> 标记</p></li>
<li><p>结尾的空白行</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DEDENT</span></code> 关闭函数声明</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENDMARKER</span></code> 结束文件</p></li>
</ul>
<p>最佳做法是在 Python 源文件的末尾有一个空行。如果省略它，CPython 会为你添加它。</p>
<p><code class="docutils literal notranslate"><span class="pre">tokenize</span></code> 模块是用纯 Python 编写的，位于 <code class="docutils literal notranslate"><span class="pre">Lib/tokenize.py</span></code> 中。</p>
<p>要查看 C 分词器的详细读数，您可以使用 <code class="docutils literal notranslate"><span class="pre">-d</span></code> 标志运行 Python。
使用之前创建的 <code class="docutils literal notranslate"><span class="pre">test_tokens.py</span></code> 脚本，使用以下命令运行它：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ./python -d test_tokens.py

Token NAME/<span class="s1">&#39;def&#39;</span> ... It<span class="s1">&#39;s a keyword</span>
<span class="s1"> DFA &#39;</span>file_input<span class="s1">&#39;, state 0: Push &#39;</span>stmt<span class="s1">&#39;</span>
<span class="s1"> DFA &#39;</span>stmt<span class="s1">&#39;, state 0: Push &#39;</span>compound_stmt<span class="s1">&#39;</span>
<span class="s1">...</span>
<span class="s1">Token NEWLINE/&#39;&#39; ... It&#39;</span>s a token we know
 DFA <span class="s1">&#39;funcdef&#39;</span>, state <span class="m">5</span>: <span class="o">[</span>switch func_body_suite to suite<span class="o">]</span> Push <span class="s1">&#39;suite&#39;</span>
 DFA <span class="s1">&#39;suite&#39;</span>, state <span class="m">0</span>: Shift.
Token INDENT/<span class="s1">&#39;&#39;</span> ... It<span class="s1">&#39;s a token we know</span>
<span class="s1"> DFA &#39;</span>suite<span class="s1">&#39;, state 1: Shift.</span>
<span class="s1">Token NAME/&#39;</span>proceed<span class="s1">&#39; ... It&#39;</span>s a keyword
 DFA <span class="s1">&#39;suite&#39;</span>, state <span class="m">3</span>: Push <span class="s1">&#39;stmt&#39;</span>
...
ACCEPT.
</pre></div>
</div>
<p>在输出中，你可以看到它突出显示了作为关键字的 <code class="docutils literal notranslate"><span class="pre">proceed</span></code>。
在下一章中，我们将看到执行 Python 二进制文件是如何到达分词器的，以及从那里执行代码时会发生什么。</p>
<blockquote>
<div><p>要清理你的代码，请恢复 <code class="docutils literal notranslate"><span class="pre">Grammar/Grammar</span></code> 中的更改，再次重新生成语法，然后清理构建并重新编译：</p>
<p>对于 macOS 或 Linux：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ git checkout -- Grammar/Grammar
$ make regen-grammar
$ make clobber
$ make -j2 -s
</pre></div>
</div>
<p>对于 Windows：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&gt; git checkout -- Grammar/Grammar
&gt; build.bat --regen
&gt; build.bat -t CleanAll
&gt; build.bat -t Build
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="id7">
<h2>一个更复杂的例子<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>添加 <code class="docutils literal notranslate"><span class="pre">proceed</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">pass</span></code> 的替代关键字是一个简单的更改，
解析器生成器将 <code class="docutils literal notranslate"><span class="pre">'proceed'</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">pass_stmt</span></code> 标记的文字进行匹配。
这个新关键字无需对编译器进行任何更改即可工作。</p>
<p>在实践中，对语法的大多数更改都更加复杂。</p>
<p>Python 3.8 引入了赋值表达式，格式为 <code class="docutils literal notranslate"><span class="pre">:=</span></code>。赋值表达式既为名称赋值，又返回命名变量的值。
受在 Python 语言中添加赋值表达式影响的语句之一是 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句。</p>
<p>在 3.8 之前，<code class="docutils literal notranslate"><span class="pre">if</span></code> 语句定义为：</p>
<ul class="simple">
<li><p>关键字 <code class="docutils literal notranslate"><span class="pre">if</span></code> 后跟 <code class="docutils literal notranslate"><span class="pre">test</span></code>，然后是 <code class="docutils literal notranslate"><span class="pre">:</span></code></p></li>
<li><p>嵌套的一系列语句（<code class="docutils literal notranslate"><span class="pre">suite</span></code>）</p></li>
<li><p>零个或多个 <code class="docutils literal notranslate"><span class="pre">elif</span></code> 语句，后跟 <code class="docutils literal notranslate"><span class="pre">test</span></code>、一个 <code class="docutils literal notranslate"><span class="pre">:</span></code> 和 <code class="docutils literal notranslate"><span class="pre">suite</span></code></p></li>
<li><p>一个可选的 <code class="docutils literal notranslate"><span class="pre">else</span></code> 语句，后跟一个 <code class="docutils literal notranslate"><span class="pre">:</span></code> 和一个 <code class="docutils literal notranslate"><span class="pre">suite</span></code></p></li>
</ul>
<p>在语法中，这表示为：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>if_stmt: &#39;if&#39; test &#39;:&#39; suite (&#39;elif&#39; test &#39;:&#39; suite)* [&#39;else&#39; &#39;:&#39; suite]
</pre></div>
</div>
<p>可视化之后看起来像：</p>
<p>为了支持赋值表达式，更改需要向后兼容。 因此，在 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句中使用 <code class="docutils literal notranslate"><span class="pre">:=</span></code> 必须是可选的。</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 语句中使用的 <code class="docutils literal notranslate"><span class="pre">test</span></code> 标记类型在许多语句之间是通用的。例如，<code class="docutils literal notranslate"><span class="pre">assert</span></code> 语句后跟一个 <code class="docutils literal notranslate"><span class="pre">test</span></code>（然后是可选的第二个 <code class="docutils literal notranslate"><span class="pre">test</span></code>）。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>assert_stmt: &#39;assert&#39; test [&#39;,&#39; test]
</pre></div>
</div>
<p>在 3.8 中添加了替代 <code class="docutils literal notranslate"><span class="pre">test</span></code> 标记类型，以便语法可以规定哪些语句应该支持赋值表达式，哪些不应该支持。</p>
<p>这个称为 <code class="docutils literal notranslate"><span class="pre">namedexpr_test</span></code>，在 <code class="docutils literal notranslate"><span class="pre">Grammer</span></code> 中定义为：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>namedexpr_test: test [&#39;:=&#39; test]
</pre></div>
</div>
<p>或者，在铁路图中可视化为：</p>
<p><img alt="namedexpr_test" src="../_images/namedexpr_test.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 语句的新语法已更改为用 <code class="docutils literal notranslate"><span class="pre">namedexpr_test</span></code> 替换 <code class="docutils literal notranslate"><span class="pre">test</span></code>：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> if_stmt: &#39;if&#39; namedexpr_test &#39;:&#39; suite (&#39;elif&#39; namedexpr_test &#39;:&#39; suite)
         [&#39;else&#39; &#39;:&#39; suite]
</pre></div>
</div>
<p>在铁路图中可视化：</p>
<p><img alt="if_stmt_namedexpr_test" src="../_images/if_stmt_with_namedexpr_test.png" /></p>
<p>为了区分 <code class="docutils literal notranslate"><span class="pre">:=</span></code> 和现有的 <code class="docutils literal notranslate"><span class="pre">COLON</span></code> (<code class="docutils literal notranslate"><span class="pre">:</span></code>) 和 <code class="docutils literal notranslate"><span class="pre">EQUAL</span></code> (<code class="docutils literal notranslate"><span class="pre">=</span></code>) 标记，将以下标记也添加到 <code class="docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code> 中：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>COLONEQUAL              &#39;:=&#39;
</pre></div>
</div>
<p>这不是支持赋值表达式所需的唯一更改。 如 <a class="reference external" href="https://github.com/python/cpython/pull/10497">Pull Request</a> 中所示，这一变化改变了 CPython 编译器的许多部分。</p>
<blockquote>
<div><p>有关 CPython 解析器生成器的更多信息，<code class="docutils literal notranslate"><span class="pre">pgen</span></code> 的作者在 PyCon Europe 2019 上录制了
有关实现和设计的演示文稿：“<a class="reference external" href="https://www.youtube.com/watch?v=1_23AVsiQEc">野兽之魂</a>”。</p>
</div></blockquote>
</div>
<div class="section" id="id8">
<h2>总结<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>在本章中，你已经了解了 Python 语法定义和解析器生成器。
在下一章中，你将扩展该知识以构建更复杂的语法功能，即“几乎等于”运算符。</p>
<p>在实践中，必须仔细考虑和讨论对 Python 语法的更改。审查水平有两个原因：</p>
<ol class="simple">
<li><p>拥有“太多”的语言特性或复杂的语法会改变 Python 作为一种简单易读的语言的精神</p></li>
<li><p>语法更改引入向后不兼容，这给所有开发人员增加了工作</p></li>
</ol>
<p>如果 Python 核心开发人员提议对语法进行更改，则必须将其作为 Python 增强提案 (PEP) 提出。
所有 PEP 都在 PEP 索引上进行编号和索引。
<a class="reference external" href="https://www.python.org/dev/peps/pep-0005/">PEP 5</a> 记录了语言发展的指南，并指定必须在 PEP 中提出更改。</p>
<p>成员还可以通过 <a class="reference external" href="https://www.python.org/community/lists/">python-ideas 邮件列表</a>建议对核心开发组之外的语言进行更改。</p>
<p>你可以在 <a class="reference external" href="https://www.python.org/dev/peps/">PEP 索引</a>中查看 CPython 未来版本的起草的、拒绝的和接受的 PEP。
一旦 PEP 达成共识，并且草案已定稿，指导委员会必须接受或拒绝它。
<a class="reference external" href="https://www.python.org/dev/peps/pep-0013/">PEP 13</a> 中定义的指导委员会的任务规定，
他们应努力“维护 Python 语言和 CPython 解释器的质量和稳定性”。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="the_standard_library.html" class="btn btn-neutral float-right" title="标准库" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="compiling_cpython.html" class="btn btn-neutral float-left" title="编译 CPython" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, qiwihui.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8SLCRRLLF9"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8SLCRRLLF9');
</script>



</body>
</html>